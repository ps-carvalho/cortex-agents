import { tool } from "@opencode-ai/plugin";
import * as fs from "fs";
import * as path from "path";

const DOCS_DIR = "docs";
const DOC_TYPES = ["decisions", "features", "flows"] as const;

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .substring(0, 60);
}

function getDatePrefix(): string {
  return new Date().toISOString().split("T")[0]; // YYYY-MM-DD
}

/** Map singular type to plural folder name */
function typeToFolder(type: string): string {
  const map: Record<string, string> = {
    decision: "decisions",
    feature: "features",
    flow: "flows",
  };
  return map[type] || type;
}

function ensureDocsDir(worktree: string, docsPath?: string): string {
  const resolved = path.join(worktree, docsPath || DOCS_DIR);
  for (const sub of DOC_TYPES) {
    fs.mkdirSync(path.join(resolved, sub), { recursive: true });
  }
  return resolved;
}

interface DocFrontmatter {
  title: string;
  type: string;
  date: string;
  status?: string;
  tags?: string[];
  related_files?: string[];
}

function parseFrontmatter(content: string): DocFrontmatter | null {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return null;

  const fm = match[1];
  const get = (key: string) => {
    const m = fm.match(new RegExp(`${key}:\\s*"?([^"\\n]+)"?`));
    return m ? m[1].trim() : undefined;
  };
  const getArray = (key: string): string[] => {
    const m = fm.match(new RegExp(`${key}:\\s*\\[([^\\]]*)]`));
    if (!m) return [];
    return m[1]
      .split(",")
      .map((s) => s.trim().replace(/^"|"$/g, ""))
      .filter(Boolean);
  };

  return {
    title: get("title") || "Untitled",
    type: get("type") || "unknown",
    date: get("date") || "",
    status: get("status"),
    tags: getArray("tags"),
    related_files: getArray("related_files"),
  };
}

// â”€â”€â”€ Templates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildFrontmatter(args: {
  title: string;
  type: string;
  status?: string;
  tags?: string[];
  relatedFiles?: string[];
}): string {
  const date = new Date().toISOString();
  const tagsStr =
    args.tags && args.tags.length > 0
      ? `[${args.tags.map((t) => `"${t}"`).join(", ")}]`
      : "[]";
  const filesStr =
    args.relatedFiles && args.relatedFiles.length > 0
      ? `[${args.relatedFiles.map((f) => `"${f}"`).join(", ")}]`
      : "[]";

  return `---
title: "${args.title}"
type: ${args.type}
date: ${date}
${args.status ? `status: ${args.status}` : ""}
tags: ${tagsStr}
related_files: ${filesStr}
---`.replace(/\n{2,}/g, "\n");
}

function buildDocument(args: {
  title: string;
  type: string;
  content: string;
  tags?: string[];
  relatedFiles?: string[];
}): string {
  const statusMap: Record<string, string> = {
    decision: "accepted",
    feature: "implemented",
    flow: "",
  };

  const frontmatter = buildFrontmatter({
    title: args.title,
    type: args.type,
    status: statusMap[args.type] || undefined,
    tags: args.tags,
    relatedFiles: args.relatedFiles,
  });

  const relatedSection =
    args.relatedFiles && args.relatedFiles.length > 0
      ? `\n\n## Related Files\n\n${args.relatedFiles.map((f) => `- \`${f}\``).join("\n")}`
      : "";

  return `${frontmatter}\n\n${args.content}${relatedSection}\n`;
}

// â”€â”€â”€ Index Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

type IndexEntry = DocFrontmatter & { filename: string; folder: string };

interface IndexSection {
  type: string;
  label: string;
  icon: string;
  entries: IndexEntry[];
}

function rebuildIndex(docsRoot: string): string {
  const sections: IndexSection[] = [
    { type: "decisions", label: "Decisions", icon: "ðŸ“‹", entries: [] },
    { type: "features", label: "Features", icon: "ðŸš€", entries: [] },
    { type: "flows", label: "Flows", icon: "ðŸ”„", entries: [] },
  ];

  for (const section of sections) {
    const folderPath = path.join(docsRoot, section.type);
    if (!fs.existsSync(folderPath)) continue;

    const files = fs
      .readdirSync(folderPath)
      .filter((f) => f.endsWith(".md") && f !== ".gitkeep")
      .sort()
      .reverse();

    for (const file of files) {
      const content = fs.readFileSync(path.join(folderPath, file), "utf-8");
      const fm = parseFrontmatter(content);
      if (fm) {
        section.entries.push({ ...fm, filename: file, folder: section.type });
      }
    }
  }

  const now = new Date().toISOString().split("T")[0];
  let index = `# Project Documentation\n\n> Auto-generated by cortex-agents. Last updated: ${now}\n`;

  for (const section of sections) {
    index += `\n## ${section.icon} ${section.label} (${section.entries.length})\n\n`;

    if (section.entries.length === 0) {
      index += `_No ${section.label.toLowerCase()} documented yet._\n`;
      continue;
    }

    if (section.type === "flows") {
      index += `| Date | Title | Tags |\n|------|-------|------|\n`;
    } else {
      index += `| Date | Title | Status | Tags |\n|------|-------|--------|------|\n`;
    }

    for (const entry of section.entries) {
      const date = entry.date ? entry.date.split("T")[0] : "â€”";
      const link = `[${entry.title}](${entry.folder}/${entry.filename})`;
      const tags = entry.tags && entry.tags.length > 0 ? entry.tags.join(", ") : "â€”";

      if (section.type === "flows") {
        index += `| ${date} | ${link} | ${tags} |\n`;
      } else {
        const status = entry.status || "â€”";
        index += `| ${date} | ${link} | ${status} | ${tags} |\n`;
      }
    }
  }

  const indexPath = path.join(docsRoot, "INDEX.md");
  fs.writeFileSync(indexPath, index);

  const totalDocs = sections.reduce((sum, s) => sum + s.entries.length, 0);
  return `âœ“ Index rebuilt: ${totalDocs} documents indexed in docs/INDEX.md`;
}

// â”€â”€â”€ Tools â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export const init = tool({
  description:
    "Initialize docs/ directory with folders for decisions, features, and flows documentation",
  args: {
    path: tool.schema
      .string()
      .optional()
      .describe("Custom docs directory path relative to project root (default: 'docs')"),
    confirm: tool.schema
      .boolean()
      .optional()
      .describe(
        "If docs/ already exists, set to true to confirm using the existing folder"
      ),
  },
  async execute(args, context) {
    const docsPath = args.path || DOCS_DIR;
    const docsRoot = path.join(context.worktree, docsPath);

    // Check if docs/ already exists
    if (fs.existsSync(docsRoot)) {
      if (!args.confirm) {
        // Check what's already there
        const existing = fs.readdirSync(docsRoot);
        return `âš  Directory '${docsPath}/' already exists with ${existing.length} entries: ${existing.join(", ")}

To use this existing folder, call docs_init again with confirm: true.
This will add the decisions/, features/, and flows/ subfolders without overwriting existing files.`;
      }
    }

    // Create folder structure
    for (const sub of DOC_TYPES) {
      const subPath = path.join(docsRoot, sub);
      fs.mkdirSync(subPath, { recursive: true });
      const gitkeep = path.join(subPath, ".gitkeep");
      if (!fs.existsSync(gitkeep)) {
        fs.writeFileSync(gitkeep, "");
      }
    }

    // Create initial INDEX.md
    const indexPath = path.join(docsRoot, "INDEX.md");
    if (!fs.existsSync(indexPath)) {
      rebuildIndex(docsRoot);
    }

    return `âœ“ Documentation directory initialized at ${docsPath}/

Structure:
  ${docsPath}/
  â”œâ”€â”€ INDEX.md          Auto-generated index of all docs
  â”œâ”€â”€ decisions/        Architecture & technology decisions (ADRs)
  â”œâ”€â”€ features/         Feature documentation with diagrams
  â””â”€â”€ flows/            Process & data flow documentation

Use docs_save to create documentation files.
Use docs_list to browse existing docs.
The INDEX.md is automatically rebuilt whenever you save a new document.`;
  },
});

export const save = tool({
  description:
    "Save a documentation file with mermaid diagrams to docs/. Auto-rebuilds the index.",
  args: {
    title: tool.schema
      .string()
      .describe("Document title (e.g., 'User Authentication System')"),
    type: tool.schema
      .enum(["decision", "feature", "flow"])
      .describe("Document type: decision (ADR), feature (component docs), or flow (sequence/process)"),
    content: tool.schema
      .string()
      .describe(
        "Full markdown content including mermaid diagram blocks. Must follow the template structure for the chosen type."
      ),
    tags: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Tags for categorization (e.g., ['auth', 'security'])"),
    relatedFiles: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe("Source files related to this document (e.g., ['src/auth.ts'])"),
  },
  async execute(args, context) {
    const { title, type, content, tags, relatedFiles } = args;

    const docsRoot = path.join(context.worktree, DOCS_DIR);
    const folder = typeToFolder(type);
    const folderPath = path.join(docsRoot, folder);

    // Auto-init if docs/ doesn't exist
    if (!fs.existsSync(folderPath)) {
      ensureDocsDir(context.worktree);
    }

    const datePrefix = getDatePrefix();
    const slug = slugify(title);
    const filename = `${datePrefix}-${slug}.md`;
    const filepath = path.join(folderPath, filename);

    // Build the full document
    const fullContent = buildDocument({
      title,
      type,
      content,
      tags,
      relatedFiles,
    });

    fs.writeFileSync(filepath, fullContent);

    // Auto-rebuild index
    const indexResult = rebuildIndex(docsRoot);

    return `âœ“ Documentation saved

File: ${folder}/${filename}
Path: ${filepath}
Type: ${type}
Tags: ${tags?.join(", ") || "none"}
Related files: ${relatedFiles?.length || 0}

${indexResult}`;
  },
});

export const list = tool({
  description: "List all documentation files in docs/",
  args: {
    type: tool.schema
      .enum(["decision", "feature", "flow", "all"])
      .optional()
      .describe("Filter by document type (default: all)"),
  },
  async execute(args, context) {
    const { type = "all" } = args;
    const docsRoot = path.join(context.worktree, DOCS_DIR);

    if (!fs.existsSync(docsRoot)) {
      return `No docs/ directory found.

Run docs_init to set up the documentation folder structure.`;
    }

    const foldersToScan =
      type === "all" ? [...DOC_TYPES] : [typeToFolder(type)];

    let output = "ðŸ“š Project Documentation:\n";
    let totalCount = 0;

    for (const folder of foldersToScan) {
      const folderPath = path.join(docsRoot, folder);
      if (!fs.existsSync(folderPath)) continue;

      const files = fs
        .readdirSync(folderPath)
        .filter((f) => f.endsWith(".md") && f !== ".gitkeep")
        .sort()
        .reverse();

      if (files.length === 0) continue;

      const icon =
        folder === "decisions" ? "ðŸ“‹" : folder === "features" ? "ðŸš€" : "ðŸ”„";
      output += `\n${icon} ${folder.charAt(0).toUpperCase() + folder.slice(1)} (${files.length}):\n\n`;

      for (const file of files) {
        const content = fs.readFileSync(path.join(folderPath, file), "utf-8");
        const fm = parseFrontmatter(content);

        const title = fm?.title || file;
        const date = fm?.date ? fm.date.split("T")[0] : file.substring(0, 10);
        const tags =
          fm?.tags && fm.tags.length > 0
            ? ` [${fm.tags.join(", ")}]`
            : "";
        const status = fm?.status ? ` (${fm.status})` : "";

        output += `  â€¢ ${title}${status}${tags}\n`;
        output += `    File: ${folder}/${file} | Date: ${date}\n\n`;
        totalCount++;
      }
    }

    if (totalCount === 0) {
      return `No documentation files found in docs/.

Use docs_save to create your first document, or docs_init to set up the folder structure.`;
    }

    output += `\nTotal: ${totalCount} documents. See docs/INDEX.md for the full index.`;
    return output;
  },
});

export const index = tool({
  description:
    "Rebuild docs/INDEX.md with links to all documentation files. Called automatically by docs_save.",
  args: {},
  async execute(_args, context) {
    const docsRoot = path.join(context.worktree, DOCS_DIR);

    if (!fs.existsSync(docsRoot)) {
      return `No docs/ directory found. Run docs_init first.`;
    }

    return rebuildIndex(docsRoot);
  },
});
